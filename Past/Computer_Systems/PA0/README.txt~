Created by Keyan Vakil
BUID- U32278684
The following README file is designed such that the Design and Testing of Sort.c is explained in the first part, while the Design and Testing of Search.c is explained in the second part. Feel free to email me at keyanv@bu.edu if you have any questions.
Sort.c
	Design:
		The program first has an integer array that can be accessed by the whole program. The main method of the program first sorts the array and prints each value in the sorted array. It does this by first implementing the BubbleSort method. Bubble Sort is a sorting algorithm with O(n^2) time that uses a simple Swap function to swap the values in the unsorted portion of an array such that the greatest number of the unsorted portion of the array becomes the smallest number in the sorted portion by looping through the unsorted portion until there are no unsorted values (see https://en.wikipedia.org/wiki/Bubble_sort). The PrintArray method takes as input an array and its length and uses the length to iterate through the array and print each value from index 0 to the inputted length. Important design considerations included how to actually Swap the values of the array if they needed to be swapped since passing in the integers would only swap the values at a local level. However, the Swap method passes in the corresponding pointers in order to actually swap the memory location of the values of the array. The program can be improved by including a way for the length of the array to be determined by the program instead of manually passing in the length of the array. This could be done by storing sizeof(Array) in an int contained in the global portion of the program just after the array has been initialized and then passing this size variable into the methods instead. Additionally, it could restrict user input to only accept integers within the range of the compiler’s understanding to prevent crashing, through input validation via an if statement and a do-while loop. The program may also benefit from a method that asks the user to input his/her own values to place in an array. However, the most functional way to do this would be to implement a dynamically allocated array, which would come at the cost of efficiency.
		Testing:
			In order to run sort.c, it is necessary to first compile it by opening terminal and typing “gcc –o sort sort.c” and hit Enter within the same directory that sort.c is located. In order to run the program, after compiling, type “./sort” to run the program. The default test case works for the array, indicating that it could correctly sort positive integers, negative integers. The test case of {2} worked, indicating that an index out of bounds error should not happen for any positive value of n. The test case of {} did not work since an array with length 0 is not declared by the compiler in my implementation. Test case of {0, 0, -1, 1, -1, 0, 0, -1, 1, 1} worked correctly, indicating it works even if there are repeating values. There are no known test cases for which my program doesn’t work, provided that the length of the array is manually changed correctly as a result of changing the array and that the integers are within the range that the C compiler will not get an overflow error. Otherwise, only arrays of size 12 work correctly.
Search.c
	Design:
		The program first has an integer array that can be accessed by the whole program. The main method of the program first sorts the array and prints each value in the sorted array using the BubbleSort and PrintArray methods copied from Sort.c. The main method then prompts the user to enter a key to search for within the array. Then, the program performs an iterative Binary Search on the array to determine at which index the key can be found. If it isn’t found, the program instead prints that the key wasn’t found. Binary Search is a search algorithm with O(log n) time that uses the value of the key and determines if it is equal to the middle value of a sorted array. If it is equal, the key and the position it can be found in is printed. Otherwise, it will perform the same step on the lower half of the array if the key is less than the middle value, or on the upper half of the array if the key is greater than the middle value, until the value is found or there isn’t more values to look for in the array (see https://en.wikipedia.org/wiki/Binary_search_algorithm). In my implementation, I couldn’t have the function print that the key wasn’t found until it has checked the entire array, so it had to be located outside of the while loop. Thus, I didn’t want the program to run after the value had been found, since otherwise, the program would always print that the key had not been found. To remedy this problem, I changed the method from a void function to an int function. After that, when the value was found I could exit out of the program by returning 0, which would not affect functionality in my implementation since the returned 0 would not be used. However, I changed the return value from 0 to the index where the array is found, simply because the user can now store that index for later use in a variable or use it in another method. The program can be improved by the same ways that sort.c can. Additionally, if there is more than one value equal to the key found in the array, the algorithm will only print the index that it finds first, instead of all the indeces it could be found. This problem can be solved by implementing a helper function to go to that index and look both ways to find the indeces of the adjacent equivalent values until the values aren’t equivalent or until the end of the array is reached. However, this would mean that the function may have to return an integer array instead of a single integer, which would affect the functionality of the program.
		Testing:
			 In order to run search.c, it is necessary to first compile it by opening terminal and typing “gcc –o search search.c” and hit Enter within the same directory that search.c is located. In order to run the program, after compiling, type “./search” to run the program. Since we know that sort.c worked, the test cases must be the user input, not changing the array. The test cases of -4, 13, and 29 worked correctly, indicating that the algorithm will iterate through the whole array during the worst and best case scenarios. Test cases of -5, 8, and 30 worked correctly as well, indicating that the algorithm should not print any false positives, regardless of whether the key is between the minimum and maximum values of the array or not. There are no known test cases for which my program doesn’t work, given the same provisions described in sort.c.

